/*
iPubSub API

A lightweight, scalable pub-sub service API that supports both real-time message delivery and persistent storage.  iPubSub enables publishers to send messages to lightweight topics/streams, and subscribers to receive messages  using efficient long-polling. Topics are created dynamically on first message without explicit provisioning.  **Core Features:** - **Real-time Matching**: Publishers and subscribers are matched in real-time using long polling - **Dynamic Topics**: Lightweight topics/streams created automatically on first message - **Dual Storage**: Messages can be delivered in-memory for real-time consumption and/or persisted for replay - **Per-message TTL**: Individual message expiration (not stream-level) - **Horizontal Scaling**: Distributed hash ring for stream routing across nodes

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package genapi

import (
	"bytes"
	"encoding/json"
	"fmt"
)

// checks if the SendRequest type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &SendRequest{}

// SendRequest struct for SendRequest
type SendRequest struct {
	// Unique identifier for the message
	MessageUuid string `json:"messageUuid"`
	// Unique identifier for the stream/topic
	StreamId string `json:"streamId"`
	// The size of the in-memory stream. Only used when writeToDB is false. Default is 100. It will be used at the first request of send API call for the stream, until the iPubSub service instance is stopped. The stream will be a circular buffer unless using blockingSendTimeoutSeconds. Circular buffer means the oldest message will be deleted when the stream is full. If using blockingSendTimeoutSeconds, the stream will not delete the oldest message when the stream is full. In certain cases, setting this to zero, and using blockingSendTimeoutSeconds, will make the stream behave like a sync match queue(no data loss but requires client to retry to wait for the stream to be available to send to).
	InMemoryStreamSize *int32 `json:"inMemoryStreamSize,omitempty"`
	// The timeout in seconds for waiting for the in-memory stream to be available to send to. Using this means the stream is not a circular buffer(not delete the oldest message when the stream is full). It will return 424 error if the stream is full after waiting. Using this with inMemoryStreamSize set to zero will make the stream behave like a sync match queue(no data loss but requires client to retry to wait for the stream to be available to send to).
	BlockingSendTimeoutSeconds *int32 `json:"blockingSendTimeoutSeconds,omitempty"`
	// The message data to send (can be any JSON value - object, array, string, number, boolean, or null)
	Message interface{} `json:"message"`
	// Whether to write to the database. By default, this is false.
	WriteToDB *bool `json:"writeToDB,omitempty"`
	// The TTL in seconds for the message in the database. Only used when writeToDB is true. Default is 24 * 60 * 60 (24 hours).
	DbTTLSeconds *int32 `json:"dbTTLSeconds,omitempty"`
}

type _SendRequest SendRequest

// NewSendRequest instantiates a new SendRequest object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewSendRequest(messageUuid string, streamId string, message interface{}) *SendRequest {
	this := SendRequest{}
	this.MessageUuid = messageUuid
	this.StreamId = streamId
	this.Message = message
	return &this
}

// NewSendRequestWithDefaults instantiates a new SendRequest object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewSendRequestWithDefaults() *SendRequest {
	this := SendRequest{}
	return &this
}

// GetMessageUuid returns the MessageUuid field value
func (o *SendRequest) GetMessageUuid() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.MessageUuid
}

// GetMessageUuidOk returns a tuple with the MessageUuid field value
// and a boolean to check if the value has been set.
func (o *SendRequest) GetMessageUuidOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.MessageUuid, true
}

// SetMessageUuid sets field value
func (o *SendRequest) SetMessageUuid(v string) {
	o.MessageUuid = v
}

// GetStreamId returns the StreamId field value
func (o *SendRequest) GetStreamId() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.StreamId
}

// GetStreamIdOk returns a tuple with the StreamId field value
// and a boolean to check if the value has been set.
func (o *SendRequest) GetStreamIdOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.StreamId, true
}

// SetStreamId sets field value
func (o *SendRequest) SetStreamId(v string) {
	o.StreamId = v
}

// GetInMemoryStreamSize returns the InMemoryStreamSize field value if set, zero value otherwise.
func (o *SendRequest) GetInMemoryStreamSize() int32 {
	if o == nil || IsNil(o.InMemoryStreamSize) {
		var ret int32
		return ret
	}
	return *o.InMemoryStreamSize
}

// GetInMemoryStreamSizeOk returns a tuple with the InMemoryStreamSize field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SendRequest) GetInMemoryStreamSizeOk() (*int32, bool) {
	if o == nil || IsNil(o.InMemoryStreamSize) {
		return nil, false
	}
	return o.InMemoryStreamSize, true
}

// HasInMemoryStreamSize returns a boolean if a field has been set.
func (o *SendRequest) HasInMemoryStreamSize() bool {
	if o != nil && !IsNil(o.InMemoryStreamSize) {
		return true
	}

	return false
}

// SetInMemoryStreamSize gets a reference to the given int32 and assigns it to the InMemoryStreamSize field.
func (o *SendRequest) SetInMemoryStreamSize(v int32) {
	o.InMemoryStreamSize = &v
}

// GetBlockingSendTimeoutSeconds returns the BlockingSendTimeoutSeconds field value if set, zero value otherwise.
func (o *SendRequest) GetBlockingSendTimeoutSeconds() int32 {
	if o == nil || IsNil(o.BlockingSendTimeoutSeconds) {
		var ret int32
		return ret
	}
	return *o.BlockingSendTimeoutSeconds
}

// GetBlockingSendTimeoutSecondsOk returns a tuple with the BlockingSendTimeoutSeconds field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SendRequest) GetBlockingSendTimeoutSecondsOk() (*int32, bool) {
	if o == nil || IsNil(o.BlockingSendTimeoutSeconds) {
		return nil, false
	}
	return o.BlockingSendTimeoutSeconds, true
}

// HasBlockingSendTimeoutSeconds returns a boolean if a field has been set.
func (o *SendRequest) HasBlockingSendTimeoutSeconds() bool {
	if o != nil && !IsNil(o.BlockingSendTimeoutSeconds) {
		return true
	}

	return false
}

// SetBlockingSendTimeoutSeconds gets a reference to the given int32 and assigns it to the BlockingSendTimeoutSeconds field.
func (o *SendRequest) SetBlockingSendTimeoutSeconds(v int32) {
	o.BlockingSendTimeoutSeconds = &v
}

// GetMessage returns the Message field value
// If the value is explicit nil, the zero value for interface{} will be returned
func (o *SendRequest) GetMessage() interface{} {
	if o == nil {
		var ret interface{}
		return ret
	}

	return o.Message
}

// GetMessageOk returns a tuple with the Message field value
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *SendRequest) GetMessageOk() (*interface{}, bool) {
	if o == nil || IsNil(o.Message) {
		return nil, false
	}
	return &o.Message, true
}

// SetMessage sets field value
func (o *SendRequest) SetMessage(v interface{}) {
	o.Message = v
}

// GetWriteToDB returns the WriteToDB field value if set, zero value otherwise.
func (o *SendRequest) GetWriteToDB() bool {
	if o == nil || IsNil(o.WriteToDB) {
		var ret bool
		return ret
	}
	return *o.WriteToDB
}

// GetWriteToDBOk returns a tuple with the WriteToDB field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SendRequest) GetWriteToDBOk() (*bool, bool) {
	if o == nil || IsNil(o.WriteToDB) {
		return nil, false
	}
	return o.WriteToDB, true
}

// HasWriteToDB returns a boolean if a field has been set.
func (o *SendRequest) HasWriteToDB() bool {
	if o != nil && !IsNil(o.WriteToDB) {
		return true
	}

	return false
}

// SetWriteToDB gets a reference to the given bool and assigns it to the WriteToDB field.
func (o *SendRequest) SetWriteToDB(v bool) {
	o.WriteToDB = &v
}

// GetDbTTLSeconds returns the DbTTLSeconds field value if set, zero value otherwise.
func (o *SendRequest) GetDbTTLSeconds() int32 {
	if o == nil || IsNil(o.DbTTLSeconds) {
		var ret int32
		return ret
	}
	return *o.DbTTLSeconds
}

// GetDbTTLSecondsOk returns a tuple with the DbTTLSeconds field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SendRequest) GetDbTTLSecondsOk() (*int32, bool) {
	if o == nil || IsNil(o.DbTTLSeconds) {
		return nil, false
	}
	return o.DbTTLSeconds, true
}

// HasDbTTLSeconds returns a boolean if a field has been set.
func (o *SendRequest) HasDbTTLSeconds() bool {
	if o != nil && !IsNil(o.DbTTLSeconds) {
		return true
	}

	return false
}

// SetDbTTLSeconds gets a reference to the given int32 and assigns it to the DbTTLSeconds field.
func (o *SendRequest) SetDbTTLSeconds(v int32) {
	o.DbTTLSeconds = &v
}

func (o SendRequest) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o SendRequest) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["messageUuid"] = o.MessageUuid
	toSerialize["streamId"] = o.StreamId
	if !IsNil(o.InMemoryStreamSize) {
		toSerialize["inMemoryStreamSize"] = o.InMemoryStreamSize
	}
	if !IsNil(o.BlockingSendTimeoutSeconds) {
		toSerialize["blockingSendTimeoutSeconds"] = o.BlockingSendTimeoutSeconds
	}
	if o.Message != nil {
		toSerialize["message"] = o.Message
	}
	if !IsNil(o.WriteToDB) {
		toSerialize["writeToDB"] = o.WriteToDB
	}
	if !IsNil(o.DbTTLSeconds) {
		toSerialize["dbTTLSeconds"] = o.DbTTLSeconds
	}
	return toSerialize, nil
}

func (o *SendRequest) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"messageUuid",
		"streamId",
		"message",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err
	}

	for _, requiredProperty := range requiredProperties {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varSendRequest := _SendRequest{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varSendRequest)

	if err != nil {
		return err
	}

	*o = SendRequest(varSendRequest)

	return err
}

type NullableSendRequest struct {
	value *SendRequest
	isSet bool
}

func (v NullableSendRequest) Get() *SendRequest {
	return v.value
}

func (v *NullableSendRequest) Set(val *SendRequest) {
	v.value = val
	v.isSet = true
}

func (v NullableSendRequest) IsSet() bool {
	return v.isSet
}

func (v *NullableSendRequest) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableSendRequest(val *SendRequest) *NullableSendRequest {
	return &NullableSendRequest{value: val, isSet: true}
}

func (v NullableSendRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableSendRequest) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
